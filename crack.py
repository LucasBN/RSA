from RSA import *

#### Attempt to crack the RSA algorithm:

### Prime number selection weaknesses:

## Reusing prime numbers, GCD can be found (one of the primes used)
## If p and q share half their upper bits, pq can be factored using Fermat's method
## If p or q contain too many contiguous zeros, Coppersmith's method can be used to factor pq
## If (p - 1) or (q - 1) has a small prime factor, Pollard (p-1) can be used to factor pq

### Private key exponent weaknesses:

## Small d speeds up decryption but if d < (pq)^0.25, private key can be recovered using continued fractions (Chinese RT can be used to work around this)

### Public key exponent:

## {2, 3, 17, 65537} - Fermat Prime

bit_length = 256

rsa = RSA(bit_length)
if not rsa.check_encryption():
    quit()

pub_key = rsa.get_public_key()
priv_key = rsa.get_private_key()

################# Small Private Key #################

if (priv_key < 2 * pow(2, 0.5) * pow(pub_key[0], 0.25) ):
    print("Vulnerable to small private key attack - Wiener Attack Method.")
else:
    print("Safe.")

from sympy.ntheory.continued_fraction import continued_fraction_periodic, continued_fraction_convergents
from sympy import fraction
import numpy as np

def wiener_attack_rsa(public_key):
    N = public_key[0]
    e = public_key[1]
    #
    cf = continued_fraction_periodic(e, N)
    convergents = list(continued_fraction_convergents(cf))

    polynomial_power = 0
    for i in convergents:
        polynomial_power += 1
        n, d = fraction(i)
        if n != 0:
            exp = ((e*d) - 1) / n
            n2, d2 = fraction(exp)
            #if d2 == 1:
            factors = (np.roots([1, -( (N-n2) + 1 ) , N]))
            return factors

#####################################################
#
# A private key small enough to be found using
# the wiener continued fractions has not yet
# ever been generated by the key generators
#
#####################################################
